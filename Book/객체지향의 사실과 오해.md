# 객체지향의 사실과 오해
![객체지향의 사실과 오해](http://image.yes24.com/momo/TopCate511/MidCate005/51040273.jpg)
http://www.yes24.com/Product/Goods/18249021

다시 보면 좋을 것 같은 구절, 인상 깊었던 구절 정리
- 책을 사서 보면 더 좋습니다

<br>

# 01: 협력하는 객체들의 공동체
> (21p) 객체지향의 목표는 실세계를 모방하는 것이 아니다. 오히려 새로운 세계를 창조하는 것이다. 소프트웨어 개발자의 역할은 단순히 실세계를 소프트웨어 안으로 옮겨 담는 것이 아니라 고객과 사용자를 만족시킬 수 있는 신세계를 창조하는 것이다.

> (24p) 모든 음료 주문은 손님이 커피를 주문하고, 캐시어가 주문을 받고, 바리스타가 커피를 제조하는 과정을 거친 후에야 완료된다. 커피를 주문하고 제조하는 과정은 **역할, 책임, 협력**이라는 사람의 일상 속에 항상 스며들어 있는 세 가지 개념이 한데 어울려 조화를 이루며 만들어 낸 것이다.

> (29p) 협력의 핵심은 특정한 책임을 수행하는 **역할들 간의 연쇄적인 요청과 응답**을 통해 목표를 달성한다는 것이다.

> (30p) 객체 공동체 안에 살고 있는 성실한 객체 시민은 자신에게 주어진 역할과 책임을 다하는 동시에 시스템의 더 큰 목적을 이루기 위해 다른 객체와도 적극적으로 협력한다.

> (30p) 결론적으로 시스템은 **역할과 책임을 수행하는 객체로 분할**되고 시스템의 기능은 **객체 간의 연쇄적인 요청과 응답의 흐름으로 구성된 협력**으로 구현된다.

> (30p) 책임은 객체지향 설계의 품질을 결정하는 가장 중요한 요소다. **책임이 불분명한 객체는 애플리케이션의 미래 역시 불분명하게 만든다.** 얼마나 적절한 책임을 선택하느냐가 애플리케이션의 아름다움을 결정한다.

> (30p) **역할은 관련성 높은 책임의 집합**이다. 객체의 역할은 사람의 역할과 유사하게 다음과 같은 특징을 지닌다.
> - 여러 객체가 동일한 역할을 수행할 수 있다.
> - 역할은 대체 가능성을 의미한다.
> - 각 객체는 책임을 수행하는 방법을 자율적으로 선택할 수 있다. (다형성)
> - 하나의 객체가 동시에 여러 역할을 수행할 수 있다.

> (31p) 객체지향 애플리케이션의 아름다움을 결정하는 것이 협력이라면, 협력이 얼마나 조화를 이루는지를 결정하는 것은 객체다. 결국 **협력의 품질을 결정하는 것은 객체의 품질**이다. 

> (33p) 객체의 사적인 부분은 객체 스스로 관리하고 외부에서 일체 간섭할 수 없도록 차단해야 하며, 객체의 외부에서는 접근이 허락된 수단을 통해서만 객체와 의사소통해야 한다. **객체는 다른 객체가 '무엇(what)'을 수행하는지 알 수 있지만 '어떻게(how)' 수행하는지에 대해서는 알 수 없다.**

> (33p) 객체는 행동을 위해 필요한 상태를 포함하는 동시에 특정한 행동을 수행하는 방법을 스스로 결정할 수 있어야 한다. 따라서 **객체는 상태와 행위를 하나의 단위로 묶는 자율적인 존재**다.

> (35p) 외부의 요청이 무엇인지를 표현하는 메시지와 요청을 처리하기 위한 구체적인 방법인 메서드를 분리하는 것은 객체의 자율성을 높이는 핵심 메커니즘이다. (캡슐화)

> (37p) 이제 많은 사람들은 객체지향이라는 말을 들으면 조건반사적으로 클래스라는 단어를 떠올린다. 어떤 객체지향 프로그래밍 언어를 이야기할 때 대부분의 사람들은 클래스를 정의하는 방법과 클래스 사이의 상속에 초점을 맞춘다.

> (38p) 지나치게 **클래스를 강조하는 프로그래밍 언어적인 관점은 객체의 캡슐화를 저해하고 클래스를 서로 강하게 결합**시킨다. 애플리케이션을 협력하는 객체들의 공동체가 아닌 클래스로 구성된 설계도로 보는 관점은 **유연하고 확장 가능한 애플리케이션의 구축을 방해**한다.

> (38p) 훌륭한 객체지향 설계자가 되기 위해서는 **메시지를 주고받는 객체의 관점으로 사고의 중심을 전환하는 것**이다. 중요한 것은 어떤 클래스가 필요한가가 아니라 **어떤 객체들이 어떤 메시지를 주고받으며 협력하는가**다. 클래스는 객체들의 협력 관계를 코드로 옮기는 도구에 불과하다.

> (38p) 객체지향의 핵심은 클래스가 아니다. 핵심은 **적절한 책임을 수행하는 역할 간의 유연하고 견고한 협력 관계를 구축**하는 것이다.

> (38p) 객체지향의 중심에는 클래스가 아니라 객체가 위치하며, 중요한 것은 **클래스들의 정적인 관계가 아니라 메시지를 주고받는 객체들의 동적인 관계**다. 

# 02: 이상한 나라의 객체

> (41p) 인간은 본능적으로 세상을 독립적이고 식별 가능한 객체의 집합으로 바라본다. 많은 사람들이 객체지향을 직관적이고 이해하기 쉬운 패러다임이라고 말하는 이유는 객체지향이 세상을 자율적이고 독립적인 객체들로 분해할 수 있는 인간의 기본적인 인지 능력에 기반을 두고 있기 때문이다.

> (41p) 그러나 현실 세계와 소프트웨어 세계 사이의 유사성은 여기까지일 뿐이다. 객체지향 패러다임의 목적은 현실 세계를 모방하는 것이 아니라 **현실 세계를 기반으로 새로운 세계를 창조하는 것**이다. 따라서 소프트웨어 세계에서 살아가는 객체는 현실 세계에 존재하는 객체와는 **전혀 다른 모습을 보이는 것이 일반적**이다.

> (47p) **객체란 식별 가능한 개체 또는 사물이다. 객체는 자동차처럼 만질 수 있는 구체적인 사물일 수도 있고, 시간처럼 추상적인 개념일 수도 있다. 객체는 구별 가능한 식별자, 특징적인 행동, 변경 가능한 상태를 가진다. 소프트웨어 안에서 객체는 저장된 상태와 실행 가능한 코드를 통해 구현된다.**

> (47p) 객체가 주변 환경과의 상호작용에 어떻게 반응하는가는 **그 시점까지 객체에 어떤 일이 발생했느냐**에 좌우된다.

> (48p) 상태를 이용하면 **과거에 얽매이지 않고 현재를 기반으로 객체의 행동 방식을 이해**할 수 있다. 상태는 근본적으로 세상의 복잡성을 완화하고 인지 과부하를 줄일 수 있는 중요한 개념이다.

> (49p) 숫자, 문자열, 양, 속도, 시간, 날짜, 참/거짓 같은 단순한 값들은 객체가 아니다. 단순한 값들은 그 자체로 독립적인 의미를 가지기보다는 다른 객체의 특성을 표현하는 데 사용된다.

> (51p) **상태는 특정 시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현한다. 객체의 상태는 객체에 존재하는 정적인 프로퍼티와 동적인 프로터티 값으로 구성된다. 객체의 프로퍼티는 단순한 값과 다른 객체를 참조하는 링크로 구분할 수 있다.**

> (52p) 객체지향의 기본 사상은 **상태와 상태를 조직하기 위한 행동을 하나의 단위로 묶는 것**이라는 점을 기억하라. 객체는 **스스로의 행동에 의해서만 상태가 변경되는 것을 보장함으로써 객체의 자율성을 유지**한다.

> (52p) 객체의 행동에 의해 객체의 상태가 변경된다는 것은 행동이 **부수 효과(Side Effect)를 초래한다는 것**을 의미한다. 앨리스가 케이크를 먹는 행위는 앨리스의 키를 작게 변화시키고 케이크의 양을 줄이는 부수 효과를 야기한다. 앨리스가 문을 통과하는 행동은 앨리스의 위치를 변화시키는 부수 효과를 초래한다.

> (55p) **행동이란 외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동이다. 행동의 결과로 객체는 자신의 상태를 변경하거나 다른 객체에게 메시지를 전달할 수 있다. 객체는 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 외부에 가시적이어야 한다.**

> (56p) 객체의 행동을 유발하는 것은 외부로부터 전달된 메시지지만 **객체의 상태를 변경할지 여부는 객체 스스로 결정**한다. 사실 객체에게 메시지를 전달하는 외부의 객체는 메시지를 수신하는 객체의 상태가 변경된다는 사실조차 알지 못한다. 메시지 송신자는 단지 자신의 요구를 메시지로 포장해서 전달할 뿐이다.

> (56p) 상태를 외부에 노출시키지 않고 행동을 경계로 캡슐화하는 것은 결과적으로 객체의 자율성을 높인다.

> (57p) 결론적으로 **상태를 잘 정의된 행동 집합 뒤로 캡슐화하는 것은 객체의 자율성을 높이고 협력을 단순하고 유연하게 만든다.** 이것이 상태를 캡슐화해야 하는 이유다.

> (58p) 식별자란 어떤 객체를 다른 객체와 구분하는 데 사용하는 객체의 프로퍼티다. 값은 식별자를 가지지 않기 때문에 **상태를 이용한 동등성 검사**를 통해 두 인스턴스를 비교해야 한다. 객체는 상태가 변경될 수 있기 떄문에 **식별자를 이용한 동일성 검사**를 통해 두 인스턴스를 비교할 수 있다.

> (60p) 일반적으로 객체의 상태를 조회하는 작업을 **쿼리(query)**라고 하고 객체의 상태를 변경하는 작업을 **명령(command)**라고 한다.

> (62p) 사용자는 명령 버튼을 눌러야만 상태를 변경할 수 있고 조회 버튼을 눌러야만 상태를 조회할 수 있다. 어떤 사용자도 직접 기계를 열어 기계 내부의 상태에 직접 접근하려고 하지 않는다. 객체에 접근할 수 있는 유일한 방법은 객체가 제공하는 행동뿐이라는 점을 강조한다. **즉, 사용자는 객체가 제공하는 명령 버튼과 쿼리 버튼으로 구성된 인터페이스를 통해서만 객체에 접근할 수 있다.**

> (62p) 객체 기계가 제공하는 버튼을 통해서만 상태에 접근할 수 있다는 점은 객체의 **캡슐화**를 강조한다.

> (64p) 초보자들은 먼저 객체에 필요한 상태가 무엇인지를 결정하고 그 상태에 필요한 행동을 결정한다.

> (65p) 협력에 참여하는 훌륭한 객체 시민을 양성하기 위한 가장 중요한 덕목은 **상태가 아니라 행동에 초점을 맞추는 것**이다.

> (65p) 설계자로서 우리는 **협력의 문맥에 맞는 적절한 행동을 수행하는 객체를 발견하거나 창조**해야 한다. 결과적으로 우리가 애플리케이션 안에서 어떤 행동을 원하느냐가 어떤 객체가 적합한지를 결정한다.

> (65p) 객체지향 설계는 애플리케이션에 필요한 협력을 생각하고, 협력에 참여하는 데 필요한 행동을 생각한 후, 행동을 수행할 객체를 선택하는 방식으로 수행된다. **행동을 결정한 후에야 행동에 필요한 정보가 무엇인지를 고려하게 되며 이 과정에서 필요한 상태가 결정**된다.

> (67p) 현실 속의 객체와 소프트웨어 객체 사이의 가장 큰 차이점은 무엇일까? 그것은 현실 속에서는 수동적인 존재가 소프트웨어 객체로 구현될 때는 **능동적**으로 변한다는 것이다.

> (67p) 현실의 객체보다 더 많은 일을 할 수 있는 소프트웨어 객체의 특징을 의인화(anthropomorphism)라고 부른다.

> (69p) 소프트웨어 객체에 대한 현실 객체의 은유를 효과적으로 사용할 경우 표현적 차이를 줄일 수 있으며, 이해하기 쉽고 유지보수가 용이한 소프트웨어를 만들 수 있다. 바로 이러한 이유로 모든 객체지향 지침서에는 현실 세계인 도메인에서 사용되는 이름을 객체에게 부여하라고 가이드하는 것이다.
