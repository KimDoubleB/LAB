# 서버 성능테스트

간단하게 정리했다!

<br>

# **테스트의 종류**

일반적으로 테스트는 3가지로 분류된다.

- **모두 정확하게 분류되는 것이 아닌 테스트 시에 섞여서 서비스의 본질에 맞게 테스트 방법이 바뀌곤 한다.**

<br>

## 1. Load Testing (부하 테스트)

**"시스템이 부하를 얼마만큼 견뎌낼 수 있는가?"**

낮은 부하부터 트래픽을 계속 증가시키며 진행하는 테스트

- 한계점을 측정하고, 그 임계치를 높이는 것이 목적

일반적으로 **동시접속자 수**와 그 때(해당 부하)의 **Response time으로 성능 측정**

<br>

## 2. Stress Testing (스트레스 테스트)

**"스트레스 상황에서 서버가 안정적인가?"**

이 테스트에선 "**스트레스 상황**"과 "**안정적 요소**" 2가지를 나눠볼 수 있다.

- 스트레스 상황
    - 최대 부하치의 동시접속자 수
    - 메모리 및 리소스 leak
    - 네트워크 이상 (대역폭 제한)
    - 등 서버 구동에 필요한 자원들을 제한하는 상황들
- 안정적 요소
    - 서버가 다운되지 않는가?
    - 로깅이 제대로 되고 있는가?
    - 보안상 이슈가 없는가?
    - 데이터 또는 데이터베이스에 결함이 생기지 않는가?
    - 서버 리소스(CPU, 메모리 등)에 이상이 없는가? (모니터링을 통해 확인)

위 스트레스 상황에서 **얼마만큼의 스트레스를 견디며 서비스가 운영**될 수 있고 **Response time**은 어떻게 되는지, 만약 스트레스로 인해 **문제가 발생하더라도 얼마나 빨리 복구**할 수 있는지 등을 측정

<br>

## 3. Performance Testing (성능 테스트)

**"서버의 성능이 어떻게 되는가?"**

서비스, 서버의 안정성 보다는 **성능에 초점**을 맞춘 테스트

**리소스 사용량, 가용량, 부하한도 등을 포함헤 Response time, Error rate 등 모든 부분이 연관되어 테스트 된다.**

---

# 성능 측정 절차

- 성능 튜닝은 객관적으로 하라
    - 당연하지만, 성능 튜닝은 주관적으로 해서는 안된다. 기준 성능 요소(base performance factor)를 기반으로 명확한 성능 목표(performance target)을 정해야 한다.
    - 성능 요소: CPU, Memory, Disk I/O, Network I/O, Response time, Fail ratio, Throughput, Resource Utilization, etc ...
- 테스트 계획과 도구를 준비
    - 테스트 일정 및 계획 수립
    - 테스트 도구 (jMeter, nGrinder, Load Runner 등) 준비
    - 점검 리스트 작성 및 활용
- 현재 상태(As-Is)를 모니터링
    - 하드웨어 장비 내역 및 세부 사양, 사용자 수, 평균 최대 응답시간, 자원 사용량
- Pilot function 추출
    - 상위 트랜잭션의 80%를 차지하는 20% 기능을 추출
- Bench mark 테스트 수행
    - 목표치 계획하고, 여러 단계로 부하를 늘리면서 테스트 → 모니터링
- 성능 특정 테이블 및 그래프 작성
    - 테스트 결과에 대한 리포트 작성 → 기록
    - 향후 개선 및 확장을 위한 자료로 활용

---

# 서버 테스트 용어 정리

**Response time:** 클라이언트의 요청을 서버에서 처리해 응답해주는 데까지 걸리는 전체 시간

- 실제 요청이 들어간 시점부터 응답을 받는 시점까지의 전체 시간
<br>

**Think time(Request Interval)**: 사용자가 request를 보내기 전까지 활동하는 시간

- 이전에 받은 Response(html 등)을 보거나 사용하는 시간으로서 서버에 따로 request를 날리지 않는 시간
<br>

**MRT (Mean Request Time)**: 유저들에 대한 평균 응답시간
<br>

**TPS (Transaction Per Second): 초당 몇 건의 트랜잭션을 수행할 수 있는가?**

- 보편적인 성능 측정 지표: 과거, 클라이언트가 직접 서버에 접속해 쿼리/트랜잭션을 요청 → 여기서 유래
- **AU / MRT**: Active User 수에 비례하고, 유저들에 대한 평균 응답시간에는 반비례
    - Active User: 서버로 요청을 보내고 응답을 기다리고 있는 사용자